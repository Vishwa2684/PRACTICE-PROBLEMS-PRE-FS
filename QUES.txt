++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A robot is placed in a n×n grid warehouse where it can move in four directions: 
"UP", "DOWN", "LEFT", and "RIGHT". Each cell in the grid represents a section 
of the warehouse, identified by its position: grid[i][j], where i is 
the row index and j is the column index. 

The indexes are starts from 0, 1, 2, and so on, row wise next row index 
starts with next number in the sequence.

The robot starts at cell grid[0][0] and follows a sequence of commands to move 
between sections.

The robot can:
    - Navigate through the grid based on the given sequence of commands.
    - Stay within the bounds of the grid—if a command attempts to move 
      the robot outside the grid, the command should be ignored.

The goal is to identify the 1D index of the robot’s final position in the grid 
after executing all the commands.

Sample Input:
---------
Line-1: An integer N, Number of days.
Line-2: N space seprated integers,  

Sample Output:
--------------
An integer array acoording to problem.


Sample Input:
-------------
2               //grid size
RIGHT DOWN      //commmands

Sample Output:
--------------
3

Explanation:
------------
The snake starts at grid[0][0] (index 0). 
- "RIGHT": moves to grid[0][1] (index 1).
- "DOWN": moves to grid[1][1] (index 3).


Sample Input:
-------------
3
DOWN LEFT RIGHT

Sample Output:
--------------
4

Explanation:
------------
The snake starts at grid[0][0] (index 0).
- "DOWN": moves to grid[1][0] (index 3).
- "LEFT": ignored (out of bounds).
- "RIGHT": moves to grid[1][1] (index 4).






++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Implement a function calculate_total_balance that accepts a list of N transaction 
amounts and the number of threads as input. The function should divide the 
transactions equally among the specified number of threads, where each thread 
processes its assigned transactions and computes the partial balance. 

The function should then aggregate the partial balances from all threads and 
return the total balance. Ensure proper synchronization to prevent data 
inconsistencies.

Sample Input:
-------------
10          // N transactions
150 -50 200 -100 250 -75 300 -125 400 -200      // amounts[]
3           //threads

Sample Output:
--------------
750


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Brahmi and his gang have been chased by a group of police officers and are now  (CLASSIC BFS)
trapped in a building with M×N rooms, arranged in a grid format. Each room is 
connected to its adjacent rooms both horizontally and vertically, forming a 
complex layout. Fortunately, some rooms in the building are designated as 
"safe zones," providing a possible escape for Brahmi and his gang.

The building's rooms are marked with the following values:
    -1 : Danger Zone - an area that Brahmi and his gang cannot enter.
    0 : Safe Zone - an area that provides a possible escape.
    -2 : Occupied by a gang member.
    
Your task is to help Brahmi and his gang reach the nearest safe zones by 
calculating the minimum distance from each gang member's room to a safe zone, 
avoiding danger zones. If a gang member is unable to reach any safe zone, 
mark their room with -2.

Input Format:
-------------
Line-1 -> two integers M and N, size of the grid of rooms.
Next M Lines -> N space separated integers, from this set [-2,-1,0] only.

Output Format:
--------------
Print an integer as result.


Sample Input-1:
---------------
4 4
-2 -1 0 -2
-2 -2 -2 -1
-2 -1 -2 -1
0 -1 -2 -2

Sample Output-1:
----------------
3 -1 0 1
2 2 1 -1
1 -1 2 -1
0 -1 3 4

NOTE: Please refer the hint.
HINT 1: FIND POSITIONS OF SAFE SPACES
HINT 2: USE THOSE POSITIONS TO FIND PLACE WHICH OTHER GANG MEMBER OCCUPIED (USE A MATRIX FOR DIRECTION)


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In a township of size N×N, each 1x1 area is either a villa or a swimming pool. 
The layout of the township is represented as a 2D matrix of size N×N, 
filled with 0's and 1's, where:
    - 0 represents a swimming pool,
    - 1 represents a villa.

Your task is to identify a swimming pool such that its distance to the nearest 
villa(s) is maximized, and return this distance.

If the township contains only villas or only swimming pools, return -1.

Note: The distance used in this problem is the Manhattan distance: the distance 
between two cells (a0, b0) and (a1, b1) is defined as |a0 - a1| + |b0 - b1|

Input Format:
-------------
- The first line contains an integer N, the size of the 2D matrix
- The next N lines each contain N space-separated integers, either 0 or 1, 
  representing the township matrix.

Output Format:
--------------
Print an integer, representing the maximum distance from any swimming pool to 
the nearest villa.


Sample Input-1:
---------------
4
1 0 1 1
0 0 0 0
1 0 1 0
1 0 0 1

Sample Output-1:
----------------
2

Explanation: 
------------
The swimming pool at (1, 1) is with distance 2 from the nearest villas.


Sample Input-2:
---------------
4
1 0 0 0
0 0 0 0
1 0 0 0
0 1 0 1

Sample Output-2:
----------------
3

Explanation: 
------------
The swimming pool at (0,3) or (1, 2) are with distance 3 from the nearest villas.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Mr. Febin is studying numbers with unique properties and is interested in 
finding all AD Numbers within a specified range.

An AD Number is a number where every pair of adjacent digits has an absolute 
difference of exactly 1.

Given two integers, start and end, identify all AD Numbers within the inclusive 
range [start,end] and output them in ascending order.

Constraints:
------------
0 <= start < end <2*10^9.
 
Input Format:
-------------
Two space-separated integers, start and end, representing the range.

Output Format:
--------------
A list of integers showing all AD Numbers in the given range.


Sample Input-1:
---------------
0 15

Sample Output-1:
----------------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]

Explanation:
------------
All numbers in this list have adjacent digits differing by exactly 1.


Sample Input-2:
---------------
25 65

Sample Output-2:
----------------
[32, 34, 43, 45, 54, 56, 65]


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ramu is given an array of numbers now he has to check for a super square matrix in the given array.

A super square matrix is a matrix such that every row sum, every column sum, and both
diagonal sums are all equal. 

The integers in the magic square do not have to be distinct. 
Every 1 x 1 grid is trivially a super square matrix 

Given an m x n integer grid , return the size (i.e., the side length k ) of the largest super square matrix that can be found
within this grid.



Example 1:

Input = 
4 5
7 1 4 5 6
2 5 1 6 4
1 5 4 3 2
1 2 7 3 4
Output: 3

Explanation: 

From the above array we have the following super square matrix of size 3 
5 1 6 
5 4 3
2 7 3 



The largest super square matrix has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12










TOOOOOOOOOOOOOOOOOOOOOOOOOFAAAAAAAAAAAAAAAAAAAAAAAAAANIIIIIIIIIIIIIIIIIIIIIIIIII CODES



Program1

Gopal is given a string s, Now he has to remove duplicate letters so that every letter appears once and only once.

He must make sure that the result produces should occur in the order given in string 

Example 1:

Input = bcabc
Output = bca


import java.util.*;
class  Solution
{
	static void removeduplicate(String word)
	{
	LinkedHashMap<Character,Integer> charCount = new LinkedHashMap<Character,Integer>();
 	
	for(int i=0;i<word.length();i++)
		{
		   if(charCount.get(word.charAt(i))==null)
			   charCount.put(word.charAt(i),1);
		   else
			   charCount.put(word.charAt(i),charCount.get(word.charAt(i))+1);
		
		}
	Set<Character> keys = charCount.keySet();
	for(char c : keys)
		System.out.print(c);


	}
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		String word = sc.next();
        new Solution().removeduplicate(word);
	}
}





back end test cases

case = 1
input=ddccbbaa
output=dcba

case = 2
input=ddabbaac
output=dabc

case = 3
input=aaaabbbbccc
output=abc

case = 4
input=aaaccccbbbbdddaaaa
output=acbd

case = 5
input=abbccaaazzzeeekkkk
output=abczek


Program2

Ragav is working with strings, which contain digits from [0-9] only.
he has to find if given string is a downgraded string or not.

A string is said to be a downgraded string, if the string follows the below rules:
	- Divide the string S into two or more substrings, like sub[0],sub[1], sub[2],..,sub[n-1]. 
	  If you append all the substrings should result in S,sub[0]+sub[1]+ sub[2]+..+sub[n-1] = S
	  
	- The numeric values of the substrings should be in decreasing order.
	  i.e., sub[0] > sub[1] > .. > sub[n-1].
	- The difference between each consecutive pair should be 1 only.
	  i.e., sub[0]-sub[1] = sub[1]-sub[2] = .. = sub[n-2]-sub[n-1] = 1.

Your task is to help Ragav to check the given numeric string is downgraded string or not. 
If yes, print "true", Otherwise print "false".

Input Format:
-------------
A String, numeric word.

Output Format:
--------------
Print a boolean result.


Sample Input-1:
---------------
004567

Sample Output-1:
----------------
false

Explanation:
------------
Numeric Word can be divided as follows: "004","5","6","7"
Given word is not a downgraded string. 


Sample Input-2:
---------------
1201100010

Sample Output-2:
----------------
true

Explanation:
------------
Numeric Word can be divided as follows: "12","011","00010"
The numeric value of substrings are: 12, 11, 10


Sample Input-3:
---------------
5040301

Sample Output-3:
----------------
false

Explanation:
------------
Numeric Word can be divided as follows: "5","04","03","01"
The numeric value of substrings are: 5,4,3,1
Rule-1 and Rule-2 are followed but Rule-3 is not followed.



Sample Input-4:
---------------
99999998

Sample Output-4:
----------------
true

Explanation:
------------
Numeric Word can be divided as follows: "9999","9998".


case =1
input=9080701
output=false

case =2
input=10009998
output=true

case =3
input=11121111200011119111180011117000111161111511114011113000111120101111
output=false

case =4
input=999998000997099060995994
output=false




import java.util.*;

class SplitString {
    public boolean splitString(String s) {
        return isRemainingValid(s, null);
    }
    private boolean isRemainingValid(String s, Long previous) {
        long current =0;
        for(int i=0;i<s.length();i++) {
            current = current * 10 + s.charAt(i)-'0';
            if(current >= 10000000000L) return false;   // Avoid overflow
            if(previous == null) {
                if (isRemainingValid(s.substring(i+1), current)) 
                    return true;
            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))
                return true;
        }
        return false;
    }
	
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		String s=sc.next();
		System.out.println(new SplitString().splitString(s));
	}
}


#######################################################################################################################

Mahalakshmi is participating in a treasure hunt that includes N boxes, each 
numbered sequentially from 0 to N-1. Initially, all the boxes are locked with 
unique passcodes, except for Box-0, which is unlocked.

Each box in the treasure hunt contains a list of envelopes, with each envelope 
holding the passcode to unlock a different box. The envelope is labeled with 
the box number it can unlock.

Mahalakshmi can open the boxes in any order, but she must start with Box-0.

The goal of the treasure hunt is to unlock all the boxes. Your task is to 
determine if Mahalakshmi can open every box and win the game.

If she can unlock all the boxes, print "Win". Otherwise, print "Lost".

Input Format:
-------------
Line-1: An integer, number of boxes.
Next N lines: space separated integers, box numbers.

Output Format:
--------------
Print a string value, Win or Lost


Sample Input-1:
---------------
5
1
2
3
4
3

Sample Output-1:
----------------
Win

Sample Input-2:
---------------
4
1 3
3 0 1
2
0

Sample Output-2:
----------------
Lost


#################################################################################################################


There are M people ordered the gold, now Mr. Manohar has to distribute the gold
to M people. Mr. Manohar, the gold merchant has N number of gold-bars, given 
as an array gold[], where gold[i] is the weight of i-th gold bar.


The process of distribution of gold is as follows:
     - He can cut the gold bar into any number of small bars, but he cannot
     join two gold bars into one.
     - He needs to distribute the gold equally among M people
     - Each person among M people has to get at most one bar.
     - Mr. Manohar can keep the gold bars that are not distributed.


Your task is to help Mr. Manohar to find the maximum weight of the gold bar 
that each person can get. If it is not possible to distribute the gold 
among M people, return 0.

NOTE: Weight of the gold bar should be at least lunit of weight (must be an integer).

Input Format:
-------------
Line-1: Two space separated integers, N and M.
Line-2: N space separated integers, weight of each gold bar.

Output Format:
--------------
Print an integer, the maximum weight of gold can be distributed.


Sample Input-1:
---------------
3 3 
5 8 6

Sample Output-l:
----------------
5


Explanation:
------------
He can cut the gold[] 45,8,6] as, gold[1] into 2 gold bars of 
weight 5 and 3, and gold[2] into 2 gold bars of weight 5 and 1. Now, there are
five gold bars of weights 5, 5, 3, 5, and 1. He can distribute 3 gold bars 
of weight 5 to 3 people.


Sample Input-2:
---------------
4 15 
2 3 4 5

Sample Output-2:
----------------
0


#################################################################################################################

You are given a grid of bulbs, where each bulb is represented by either a 1 (ON)
or a 0 (OFF). You are allowed to perform the following operation:

    - Choose any row or column in the grid and toggle the bulbs. When you toggle, 
    bulbs that are ON (1) will turn OFF (0), and bulbs that are OFF (0) will
    turn ON (1).

Your task is to maximize the sum of the binary values of each row after
performing the toggle operation any number of times.

Calculate the highest possible sum of all the binary values of each row in 
the grid after applying the operations.

Input Format:
-------------
Line-1: Two space separated integers, M and N
Next M lines: N space separated integers, grid[][]

Output Format:
--------------
Print an integer result.


Sample Input-1:
---------------
3 5
0 1 1 1 1 
1 0 1 1 1 
0 0 0 0 1 

Sample Output-1:
----------------
78

Explanation:
------------
Given grid is 
0 1 1 1 1
1 0 1 1 1
0 0 0 0 1

Perform operation on row-0 and row-2
1 0 0 0 0
1 0 1 1 1
1 1 1 1 0

Perform operation on col-1 and col-4
1 1 0 0 1 = 25
1 1 1 1 0 = 30
1 0 1 1 1 = 23
So, now the total value of Binary Equivalent is 78


Sample Input-2:
---------------
2 3
0 1 0
0 0 1

Sample Output-2:
----------------
11

#################################################################################################################


Shakuni playing 'Paramapadasopanam' game with Dharamaraja.
Shakuni wants to win everytime. He has a boon that whenever he used to 
roll the dice, the dice roll to show his desired number. 

Rules
--------
The game is played with a cubic dice of 6 faces numbered 1 to 6.
And Paramapadasopanam of size N*N.
- Starting from square X = 1, reach the square N*N with some rolls of the dice 
- Once Shakuni roll the dice, he will land on one of the followin squares only
  X+1, X+2, X+3, X+4, X+5, X+6.
- If current value at position X is not equal to -1, then there is a ladder 
  or snake.
- If the position of X is at the base of a ladder, the player must climb 
  the ladder. Ladders go up only.
- If the position of X is at the mouth of a snake, the player must go down 
  the snake and come out through the tail. Snakes go down only.

You have to findout, what would be the least number of rolls required 
for shakuni to win.

Note:
Shakuni can only take a snake or ladder at most once per move: 
if the tail of a snake or ladder is the start of another snake or ladder, 
you do not continue moving.


Input Format:
-------------
Line-1: An integer n , size of Paramapadasopanam.
Next N lines: N space separated integers, either -1 or 
              an integer between 1 to n*n. 

Output Format:
--------------
Print an integer, least number of rolls required for shakuni to win.


Sample Input-1:
---------------
6
-1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1
-1 35 -1 -1 13 -1
-1 -1 -1 -1 -1 -1
-1 15 -1 -1 -1 -1

Sample Output-1:
----------------
4

Explanation: 
------------
At the beginning, you start at square 1.
Roll the dice to land at square 2, and must take the ladder to square 15.
Roll the dice to land at square 17, and must take the snake to square 13.
Roll the dice to land at square 14, and must take the ladder to square 35.
Roll the dice to land at square 36, Shakuni Won.
Total number of rolls are 4.


#################################################################################################################


Mr Sudhakar is playing a game on checkerboard of size INF*INF (INF -infinity), 
where the indices starts from (-INF,-INF) and ends at (INF,INF). In one step, 
he can move the box from position (p,q) to one of the following positions in L 
shape like as follows: 
	- (p-2, q-1), (p-2, q+1), (p+2, q-1), (p+2, q+1)
	- (p-1, q+2), (p+1, q+2), (p-1, q-2), (p+1, q-2)

Initially the box is at (0,0) position, and need to move the box to position (m,n).
You will be given two integers m and n indicates the position(m,n).

Now your task is to help by Mr Sudhakar to find the minimum number of steps 
required to move the box from (0,0) to (m,n).


Input Format:
-----------------
Two space separated integers, m and n, position.

Output Format:
------------------
Print an integer, minimum number of steps to reach (m,n).


Sample Input-1:
---------------
2 4

Sample Output-1:
----------------
2

Explanation:
-------------
Initially, you are at (0,0) position, you can reach (2,4) as follows:
(0,0) -> (1, 2) -> (2, 4) 


Sample Input-2:
---------------
4 7

Sample Output-2:
----------------
5

Explanation:
------------
Initially, you are at (0,0) position, you can reach (4,7) as follows:
(0,0) -> (1, 2) -> (2, 4) -> (1, 6) -> (3, 5) -> (4, 7)


#################################################################################################################

A system is designed to distribute even-sized allocations for a given 
resourceLimit. The goal is to maximize the number of unique allocations 
while ensuring that their sum equals resourceLimit.

Given an integer resourceLimit, split it into a sum of a maximum number of 
unique positive even integers. The following conditions must be met:
    - Each allocation must be a unique positive even integer.
    - The total sum of the integers must equal resourceLimit.
    - The number of integers in the split must be maximized.
    
If it is not possible to split resourceLimit into valid even allocations, 
return an empty list.

Input Format:
-------------
A single integer, resourceLimit (1 ≤ resourceLimit ≤ 10^9).

Output Format:
--------------
A list of integers representing the allocations. 
If no valid allocations exist, return an empty list.


Sample Input-1:
---------------
12

Sample Output-1:
----------------
[2, 4, 6]

Explanation:
------------
The possible splits are:
    - [12] (1 allocation)
    - [2, 10] (2 allocations)
    - [2, 4, 6] (3 allocations)
The split [2, 4, 6] has the maximum number of allocations.


Sample Input-2:
---------------
7

Sample Output-2:
----------------
[]

Explanation: 
------------
It's not possible to split 7 into unique positive even integers.

Sample Input-3:
---------------
28

Sample Output-3:
----------------
[2, 4, 6, 16]

Explanation: 
The possible splits are:
    - [2, 26] (2 allocations)
    - [6, 8, 2, 12] (4 allocations)
    - [2, 4, 6, 16] (4 allocations)

The split [2, 4, 6, 16] has the maximum number of allocations.

NOTE:
=====
Please refer the sample outputs to generate the solution.


#################################################################################################################

QUESTION: BACKTRACKING
------------------------------------------------------
There are some cubes, and each cube has an alphabet (from A to Z) 
printed on it. You can construct different, non-empty words using these 
cubes and each of the word length should be 0 < length <= number of cubes.

You are given a string of alphabets S, 
Your task is to findout number of possible non-empty distinct words

Input Format:
-------------
A string S, consist of A-Z letters only.

Output Format:
--------------
Print an integer, number of possible non-empty distinct words.


Sample Input-1:
---------------
EGG

Sample Output-1:
----------------
8

Explanation:
--------------
The possible distinct words are "E", "G", "EG", "GG", "GE", "EGG", "GEG", "GGE".


Sample Input-2:
---------------
MADAM

Sample Output-2:
----------------
89
------------------------------------------------------
SOLUTION:
------------------------------------------------------
private static void backtrack(String s, StringBuilder cur, Set<String> res, boolean[] used) {
    if (cur.length() > 0) {
        res.add(cur.toString());
    }
    for (int i = 0; i < s.length(); i++) {
        if (used[i]) continue;
        used[i] = true;
        cur.append(s.charAt(i));
        backtrack(s, cur, res, used);
        cur.deleteCharAt(cur.length() - 1);
        used[i] = false;
    }
}

private static int count(String s) {
    Set<String> res = new HashSet<>();
    boolean[] used = new boolean[s.length()];
    backtrack(s, new StringBuilder(), res, used);
    return res.size();
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String S = sc.next();
    System.out.println(count(S));
}
------------------------------------------------------
ANOTHER METHOD INCLUDES, USING A FREQUENCY MAP OF A STRING:
------------------------------------------------------
void backtrack(unordered_map<char, int>& mp, int& res) {
  res++;
  for(auto& p: mp) {
    int x = p.first;
    int y = p.second;
    if(y != 0){
      mp[x]--;
      backtrack (mp, res);
      mp[x]++;
      }
    }
}
------------------------------------------------------

#################################################################################################################

You are given a set of N integers, and a value to find F. Initially a variable, 
'total' is set to 0. You can perform either addition(+) or subtraction(-)
of every integer from the set to the 'total'. The resultant total should be
equal to the value F.

Your task is to find out the number of ways, you can make the 'total' equal to
the value F.

Input Format:
-------------
Line-1: Two integers N and F.
Line-2: N space separated integers 

Output Format:
--------------
Print an integer, number of ways.


Sample Input:
---------------
5 3
1 1 1 1 1

Sample Output:
----------------
5

Explanation:
------------
total = -1+1+1+1+1 = 3 -> total=value-F
total = +1-1+1+1+1 = 3 -> total=value-F
total = +1+1-1+1+1 = 3 -> total=value-F
total = +1+1+1-1+1 = 3 -> total=value-F
total = +1+1+1+1-1 = 3 -> total=value-F

NOTE: + means addition, - means subtraction


#################################################################################################################

Mr Ajay Sharma is working woth words.
He found that few words in the langugage have same meaning.
Such words are given as a list of pairs as mappedpairs[],
where mappedpairs[i] = [word1, word2] indicates that word1 and word2 are 
the words with same meaning.

He is given phrase, and he wants to apply all the mappedpairs[] on the phrase.

Your task is to help Mr.Ajay Sharma to find and return all possible 
Mapped Phrases generated after applying all the mapped words,
and print them in lexicographical order.


Input Format:
-------------
Line-1: An integer N, number of mapped pairs.
Next N lines: Two space separated words, mappedpair[].
Last Line: A line of words, the phrase.

Output Format:
--------------
Print the list of mapped phrases in sorted order.


Sample Input-1:
---------------
3
hi hello
sweet sugar
candy chocolate
hi sam! ram has a sugar candy

Sample Output-1:
----------------
[hello sam! he has sugar candy, hello sam! he has sugar chocolate, 
hello sam! he has sweet candy, hello sam! he has sweet chocolate, 
hi sam! he has sugar candy, hi sam! he has sugar chocolate, 
hi sam! he has sweet candy, hi sam! he has sweet chocolate]



Sample Input-2:
---------------
2
hi hey
hey hello
hi how are you

Sample Output-2:
----------------
[hello how are you, hey how are you, hi how are you]

#################################################################################################################

/*
There are N rooms in a row, and all the rooms are locked initially.
You will be provided the master key. You can use the master key only once, and
you can unlock any one room and find a key in it of some other room. 
You have to repeat this process until you can find the keys of the locked rooms. 
You have to stop this process once you find the key of a room 
which is already unlocked.

You are given an array of keys[], where i-th room contains the key of key[i]-th
room and values of keys[] are range from [0..N-1] without duplicates. Your task 
is to find the maximum number of rooms can be unlocked including the first room.

Input Format:
-------------
Line-1: An integer N, number of rooms.
Line-2: N space separated integers, keys of rooms.

Output Format:
--------------
Print an integer result.
 
Sample Input-1:
---------------
8
7 4 6 2 1 0 3 5

Sample Output-1:
----------------
3

Explanation:
-----------
keys[0] = 7, keys[1] = 4, keys[2] = 6, keys[3] = 2, keys[4] = 1, keys[5] = 0, 
keys[6] = 3, keys[7]=5.

You can start with Room-0 using the master key, you can open the following rooms:
  key[0]=7 =>  key[7]=5  =>  key[5]=0
          or
  key[2]=6 =>  key[6]=3  =>  key[3]=2

You can unlock maximum 3 rooms.

Sample Input-2:
---------------
 6
 3 2 4 0 5 1

 Sample Output-2:
 ----------------
 4
 
Sample Input-3:
---------------
5
0 1 2 3 4

 Sample Output-3:
----------------
1
*/

#################################################################################################################

Ms Manasa is working on numbers; she is fascinated by number factors.
She is given a number N, she wants to find out all possible ways of 
obtaining N as multiple of its factors.
For example given N =12
can be written as multiple of 2,3 and 4.
and the ways to obtains 12 from ots factors are: 2*2*3, 2*6, 3*4

Your task is to help Ms Manasa to find the all possible ways of obtaining N 
from its factors and return all the possible ways as shown in the samples.

Input Format:
-------------
An integer N, value of N.

Output Format:
--------------
Print the list of possiblilties.


Sample Input-1:
---------------
12

Sample Output-1:
----------------
[[2, 2, 3], [2, 6], [3, 4]]


Sample Input-2:
---------------
16

Sample Output-2:
----------------
[[2, 2, 2, 2], [2, 2, 4], [2, 8], [4, 4]]


Sample Input-3:
---------------
32

Sample Output-3:
----------------
[[2, 2, 2, 2, 2], [2, 2, 2, 4], [2, 2, 8], [2, 4, 4], [2, 16], [4, 8]]

#################################################################################################################

Given a nokia phone,with the following dialpad.
		1 2 3
		4 5 6
		7 8 9
		* 0 #
And You are given an L band to dial the number,  
Using the L band you can dial the number as follows, 
You can start with any digit,
	if you are at digit 1, next digit you can choose {6,8}
	if you are at digit 2, next digit you can choose {7,9}
	if you are at digit 3, next digit you can choose {4,8}
	and so on..

Now your task is to find how many distinct numbers of length N you can dial.

Note: Numbers should contain only digits, no {* , #}.
Answer is modulo 1000000007.

Input Format:
-----------------
An integer N, length of numbers
 
Output Format:
------------------
Print an integer, number of distinct numbers you can dial.


Sample Input-1:
---------------
1

Sample Output-1:
----------------
10

Explanation:
-------------
To dial a number of length 1, you can dial all digits.


Sample Input-2:
---------------
2

Sample Output-2:
----------------
20

Explanation:
------------
To dial a number of length 2, the possible numbers are
{04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94}

Sample Input-3:
---------------
5

Sample Output-3:
----------------
240

#################################################################################################################

Given an 2D character array, Letters[][], of size r*c.
You have to construct the word W, using the given array.

Rules to construct the word are as follows:
	- All the letters of the word W, should be adjacent to each other 
	in the array Letters(either horizontal or vertical).
	- You can use each charcater in Letters[][] only once.

If you are able to construct the word W, return 'true'
Otherwise 'false'.

Input Format:
-------------
Line-1 -> two integers R and C, array size.
R lines -> C space separated characters.
Last line -> a string, word W

Output Format:
--------------
print the boolean result.


Sample Input-1:
---------------
3 3
a b c
d e f
g h i
bad

Sample Output-1:
----------------
true


Sample Input-2:
---------------
3 3
a b c
d e f
g h i
ace

Sample Output-2:
----------------
false


Sample Input-3:
---------------
3 3
a b c
d e f
g h i
add

Sample Output-3:
----------------
false

#################################################################################################################

Mr Parandhamayya working with words.
He is given a word W, you need to divide the word into N non-empty parts, 
such that all the newly formed words should be distinct, and 
if you append all those words should form original word W.

Your task is to help Mr Parandhamayya to divide the word into N parts,
such that, the value of N should be maximized, and print N.

Input Format:
-------------
Line-1: A string W, a word.

Output Format:
--------------
Print an integer result, the value of N.


Sample Input-1:
---------------
banana

Sample Output-1:
----------------
4

Explanation: 
------------
One way to divide the word is "b","a","n","ana".
If you divide it like "b","a","n","an","a".The word "a" will be repeated.
So it is not allowed to divide like the second way.


Sample Input-2:
---------------
mississippi

Sample Output-2:
----------------
7

Explanation: 
------------
One of the way to divide the word is "m","i","s","si","ssi","p","pi".

NOTE: Subsequences are not allowed.

#################################################################################################################

The Pandavas and Kauravas each rule different kingdoms separated by a river. 
If the two kingdoms are connected, the land will form a square-shaped area. 
The kingdoms are represented by cells marked with 1, and the river is 
represented by cells marked with 0.

The Pandavas and Kauravas have decided to build a bridge over the river to 
improve connectivity between their kingdoms. To minimize the cost of construction, 
they aim to reduce the length of the bridge. The bridge can only be built on 
river cells that are connected in the four cardinal directions (up, down, left, 
and right).

Your task is to help the rulers minimize the number of river cells used for 
building the bridge, and return the count of river cells occupied.

Input Format:
-------------
Line-1: An integer N, size of the land.
Next N lines: N space separated integers, either 0 or 1. 

Output Format:
--------------
Print an integer result.


Sample Input-1:
---------------
4
1 1 1 0
1 0 0 0
1 0 0 1
0 0 1 1

Sample Output-1:
----------------
2


Sample Input-2:
---------------
5
1 1 0 0 0
1 1 0 0 0
0 0 0 0 1
0 0 0 1 1
0 0 1 1 1

Sample Output-2:
----------------
3


#################################################################################################################
