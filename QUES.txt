++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A robot is placed in a n×n grid warehouse where it can move in four directions: 
"UP", "DOWN", "LEFT", and "RIGHT". Each cell in the grid represents a section 
of the warehouse, identified by its position: grid[i][j], where i is 
the row index and j is the column index. 

The indexes are starts from 0, 1, 2, and so on, row wise next row index 
starts with next number in the sequence.

The robot starts at cell grid[0][0] and follows a sequence of commands to move 
between sections.

The robot can:
    - Navigate through the grid based on the given sequence of commands.
    - Stay within the bounds of the grid—if a command attempts to move 
      the robot outside the grid, the command should be ignored.

The goal is to identify the 1D index of the robot’s final position in the grid 
after executing all the commands.

Sample Input:
---------
Line-1: An integer N, Number of days.
Line-2: N space seprated integers,  

Sample Output:
--------------
An integer array acoording to problem.


Sample Input:
-------------
2               //grid size
RIGHT DOWN      //commmands

Sample Output:
--------------
3

Explanation:
------------
The snake starts at grid[0][0] (index 0). 
- "RIGHT": moves to grid[0][1] (index 1).
- "DOWN": moves to grid[1][1] (index 3).


Sample Input:
-------------
3
DOWN LEFT RIGHT

Sample Output:
--------------
4

Explanation:
------------
The snake starts at grid[0][0] (index 0).
- "DOWN": moves to grid[1][0] (index 3).
- "LEFT": ignored (out of bounds).
- "RIGHT": moves to grid[1][1] (index 4).






++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Implement a function calculate_total_balance that accepts a list of N transaction 
amounts and the number of threads as input. The function should divide the 
transactions equally among the specified number of threads, where each thread 
processes its assigned transactions and computes the partial balance. 

The function should then aggregate the partial balances from all threads and 
return the total balance. Ensure proper synchronization to prevent data 
inconsistencies.

Sample Input:
-------------
10          // N transactions
150 -50 200 -100 250 -75 300 -125 400 -200      // amounts[]
3           //threads

Sample Output:
--------------
750


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Brahmi and his gang have been chased by a group of police officers and are now  (CLASSIC BFS)
trapped in a building with M×N rooms, arranged in a grid format. Each room is 
connected to its adjacent rooms both horizontally and vertically, forming a 
complex layout. Fortunately, some rooms in the building are designated as 
"safe zones," providing a possible escape for Brahmi and his gang.

The building's rooms are marked with the following values:
    -1 : Danger Zone - an area that Brahmi and his gang cannot enter.
    0 : Safe Zone - an area that provides a possible escape.
    -2 : Occupied by a gang member.
    
Your task is to help Brahmi and his gang reach the nearest safe zones by 
calculating the minimum distance from each gang member's room to a safe zone, 
avoiding danger zones. If a gang member is unable to reach any safe zone, 
mark their room with -2.

Input Format:
-------------
Line-1 -> two integers M and N, size of the grid of rooms.
Next M Lines -> N space separated integers, from this set [-2,-1,0] only.

Output Format:
--------------
Print an integer as result.


Sample Input-1:
---------------
4 4
-2 -1 0 -2
-2 -2 -2 -1
-2 -1 -2 -1
0 -1 -2 -2

Sample Output-1:
----------------
3 -1 0 1
2 2 1 -1
1 -1 2 -1
0 -1 3 4

NOTE: Please refer the hint.
HINT 1: FIND POSITIONS OF SAFE SPACES
HINT 2: USE THOSE POSITIONS TO FIND PLACE WHICH OTHER GANG MEMBER OCCUPIED (USE A MATRIX FOR DIRECTION)


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In a township of size N×N, each 1x1 area is either a villa or a swimming pool. 
The layout of the township is represented as a 2D matrix of size N×N, 
filled with 0's and 1's, where:
    - 0 represents a swimming pool,
    - 1 represents a villa.

Your task is to identify a swimming pool such that its distance to the nearest 
villa(s) is maximized, and return this distance.

If the township contains only villas or only swimming pools, return -1.

Note: The distance used in this problem is the Manhattan distance: the distance 
between two cells (a0, b0) and (a1, b1) is defined as |a0 - a1| + |b0 - b1|

Input Format:
-------------
- The first line contains an integer N, the size of the 2D matrix
- The next N lines each contain N space-separated integers, either 0 or 1, 
  representing the township matrix.

Output Format:
--------------
Print an integer, representing the maximum distance from any swimming pool to 
the nearest villa.


Sample Input-1:
---------------
4
1 0 1 1
0 0 0 0
1 0 1 0
1 0 0 1

Sample Output-1:
----------------
2

Explanation: 
------------
The swimming pool at (1, 1) is with distance 2 from the nearest villas.


Sample Input-2:
---------------
4
1 0 0 0
0 0 0 0
1 0 0 0
0 1 0 1

Sample Output-2:
----------------
3

Explanation: 
------------
The swimming pool at (0,3) or (1, 2) are with distance 3 from the nearest villas.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Mr. Febin is studying numbers with unique properties and is interested in 
finding all AD Numbers within a specified range.

An AD Number is a number where every pair of adjacent digits has an absolute 
difference of exactly 1.

Given two integers, start and end, identify all AD Numbers within the inclusive 
range [start,end] and output them in ascending order.

Constraints:
------------
0 <= start < end <2*10^9.
 
Input Format:
-------------
Two space-separated integers, start and end, representing the range.

Output Format:
--------------
A list of integers showing all AD Numbers in the given range.


Sample Input-1:
---------------
0 15

Sample Output-1:
----------------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]

Explanation:
------------
All numbers in this list have adjacent digits differing by exactly 1.


Sample Input-2:
---------------
25 65

Sample Output-2:
----------------
[32, 34, 43, 45, 54, 56, 65]


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ramu is given an array of numbers now he has to check for a super square matrix in the given array.

A super square matrix is a matrix such that every row sum, every column sum, and both
diagonal sums are all equal. 

The integers in the magic square do not have to be distinct. 
Every 1 x 1 grid is trivially a super square matrix 

Given an m x n integer grid , return the size (i.e., the side length k ) of the largest super square matrix that can be found
within this grid.



Example 1:

Input = 
4 5
7 1 4 5 6
2 5 1 6 4
1 5 4 3 2
1 2 7 3 4
Output: 3

Explanation: 

From the above array we have the following super square matrix of size 3 
5 1 6 
5 4 3
2 7 3 



The largest super square matrix has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12










TOOOOOOOOOOOOOOOOOOOOOOOOOFAAAAAAAAAAAAAAAAAAAAAAAAAANIIIIIIIIIIIIIIIIIIIIIIIIII CODES



Program1

Gopal is given a string s, Now he has to remove duplicate letters so that every letter appears once and only once.

He must make sure that the result produces should occur in the order given in string 

Example 1:

Input = bcabc
Output = bca


import java.util.*;
class  Solution
{
	static void removeduplicate(String word)
	{
	LinkedHashMap<Character,Integer> charCount = new LinkedHashMap<Character,Integer>();
 	
	for(int i=0;i<word.length();i++)
		{
		   if(charCount.get(word.charAt(i))==null)
			   charCount.put(word.charAt(i),1);
		   else
			   charCount.put(word.charAt(i),charCount.get(word.charAt(i))+1);
		
		}
	Set<Character> keys = charCount.keySet();
	for(char c : keys)
		System.out.print(c);


	}
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		String word = sc.next();
        new Solution().removeduplicate(word);
	}
}





back end test cases

case = 1
input=ddccbbaa
output=dcba

case = 2
input=ddabbaac
output=dabc

case = 3
input=aaaabbbbccc
output=abc

case = 4
input=aaaccccbbbbdddaaaa
output=acbd

case = 5
input=abbccaaazzzeeekkkk
output=abczek


Program2

Ragav is working with strings, which contain digits from [0-9] only.
he has to find if given string is a downgraded string or not.

A string is said to be a downgraded string, if the string follows the below rules:
	- Divide the string S into two or more substrings, like sub[0],sub[1], sub[2],..,sub[n-1]. 
	  If you append all the substrings should result in S,sub[0]+sub[1]+ sub[2]+..+sub[n-1] = S
	  
	- The numeric values of the substrings should be in decreasing order.
	  i.e., sub[0] > sub[1] > .. > sub[n-1].
	- The difference between each consecutive pair should be 1 only.
	  i.e., sub[0]-sub[1] = sub[1]-sub[2] = .. = sub[n-2]-sub[n-1] = 1.

Your task is to help Ragav to check the given numeric string is downgraded string or not. 
If yes, print "true", Otherwise print "false".

Input Format:
-------------
A String, numeric word.

Output Format:
--------------
Print a boolean result.


Sample Input-1:
---------------
004567

Sample Output-1:
----------------
false

Explanation:
------------
Numeric Word can be divided as follows: "004","5","6","7"
Given word is not a downgraded string. 


Sample Input-2:
---------------
1201100010

Sample Output-2:
----------------
true

Explanation:
------------
Numeric Word can be divided as follows: "12","011","00010"
The numeric value of substrings are: 12, 11, 10


Sample Input-3:
---------------
5040301

Sample Output-3:
----------------
false

Explanation:
------------
Numeric Word can be divided as follows: "5","04","03","01"
The numeric value of substrings are: 5,4,3,1
Rule-1 and Rule-2 are followed but Rule-3 is not followed.



Sample Input-4:
---------------
99999998

Sample Output-4:
----------------
true

Explanation:
------------
Numeric Word can be divided as follows: "9999","9998".


case =1
input=9080701
output=false

case =2
input=10009998
output=true

case =3
input=11121111200011119111180011117000111161111511114011113000111120101111
output=false

case =4
input=999998000997099060995994
output=false




import java.util.*;

class SplitString {
    public boolean splitString(String s) {
        return isRemainingValid(s, null);
    }
    private boolean isRemainingValid(String s, Long previous) {
        long current =0;
        for(int i=0;i<s.length();i++) {
            current = current * 10 + s.charAt(i)-'0';
            if(current >= 10000000000L) return false;   // Avoid overflow
            if(previous == null) {
                if (isRemainingValid(s.substring(i+1), current)) 
                    return true;
            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))
                return true;
        }
        return false;
    }
	
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		String s=sc.next();
		System.out.println(new SplitString().splitString(s));
	}
}


#######################################################################################################################

Mahalakshmi is participating in a treasure hunt that includes N boxes, each 
numbered sequentially from 0 to N-1. Initially, all the boxes are locked with 
unique passcodes, except for Box-0, which is unlocked.

Each box in the treasure hunt contains a list of envelopes, with each envelope 
holding the passcode to unlock a different box. The envelope is labeled with 
the box number it can unlock.

Mahalakshmi can open the boxes in any order, but she must start with Box-0.

The goal of the treasure hunt is to unlock all the boxes. Your task is to 
determine if Mahalakshmi can open every box and win the game.

If she can unlock all the boxes, print "Win". Otherwise, print "Lost".

Input Format:
-------------
Line-1: An integer, number of boxes.
Next N lines: space separated integers, box numbers.

Output Format:
--------------
Print a string value, Win or Lost


Sample Input-1:
---------------
5
1
2
3
4
3

Sample Output-1:
----------------
Win

Sample Input-2:
---------------
4
1 3
3 0 1
2
0

Sample Output-2:
----------------
Lost


#################################################################################################################


There are M people ordered the gold, now Mr. Manohar has to distribute the gold
to M people. Mr. Manohar, the gold merchant has N number of gold-bars, given 
as an array gold[], where gold[i] is the weight of i-th gold bar.


The process of distribution of gold is as follows:
     - He can cut the gold bar into any number of small bars, but he cannot
     join two gold bars into one.
     - He needs to distribute the gold equally among M people
     - Each person among M people has to get at most one bar.
     - Mr. Manohar can keep the gold bars that are not distributed.


Your task is to help Mr. Manohar to find the maximum weight of the gold bar 
that each person can get. If it is not possible to distribute the gold 
among M people, return 0.

NOTE: Weight of the gold bar should be at least lunit of weight (must be an integer).

Input Format:
-------------
Line-1: Two space separated integers, N and M.
Line-2: N space separated integers, weight of each gold bar.

Output Format:
--------------
Print an integer, the maximum weight of gold can be distributed.


Sample Input-1:
---------------
3 3 
5 8 6

Sample Output-l:
----------------
5


Explanation:
------------
He can cut the gold[] 45,8,6] as, gold[1] into 2 gold bars of 
weight 5 and 3, and gold[2] into 2 gold bars of weight 5 and 1. Now, there are
five gold bars of weights 5, 5, 3, 5, and 1. He can distribute 3 gold bars 
of weight 5 to 3 people.


Sample Input-2:
---------------
4 15 
2 3 4 5

Sample Output-2:
----------------
0


#################################################################################################################

You are given a grid of bulbs, where each bulb is represented by either a 1 (ON)
or a 0 (OFF). You are allowed to perform the following operation:

    - Choose any row or column in the grid and toggle the bulbs. When you toggle, 
    bulbs that are ON (1) will turn OFF (0), and bulbs that are OFF (0) will
    turn ON (1).

Your task is to maximize the sum of the binary values of each row after
performing the toggle operation any number of times.

Calculate the highest possible sum of all the binary values of each row in 
the grid after applying the operations.

Input Format:
-------------
Line-1: Two space separated integers, M and N
Next M lines: N space separated integers, grid[][]

Output Format:
--------------
Print an integer result.


Sample Input-1:
---------------
3 5
0 1 1 1 1 
1 0 1 1 1 
0 0 0 0 1 

Sample Output-1:
----------------
78

Explanation:
------------
Given grid is 
0 1 1 1 1
1 0 1 1 1
0 0 0 0 1

Perform operation on row-0 and row-2
1 0 0 0 0
1 0 1 1 1
1 1 1 1 0

Perform operation on col-1 and col-4
1 1 0 0 1 = 25
1 1 1 1 0 = 30
1 0 1 1 1 = 23
So, now the total value of Binary Equivalent is 78


Sample Input-2:
---------------
2 3
0 1 0
0 0 1

Sample Output-2:
----------------
11

#################################################################################################################
